# 2018年3月4日12:39:53
修正之前的错误，其实代码也可以从read-write的区域执行，但是此时EL0不能访问这些区域。也就是说，合理的AP[2:1]取值为0b00,0b1x
正确地映射了RAM，现在代码能够正常执行到最后。也就是能够通过TTBR1_EL1正确映射。
# 2018年3月3日13:36:19
今日成功地启用了MMU
之前的错误及其修正：
TTBR的BADDR域必须设置成0级页表地址右移1位
页表的地址域必须设成基本地址右移12位
之前产生了Permission Fault,原因是块描述符或者页描述符的AP域设成了01, 可读写，可从EL0访问。改成1x, 只读，正确。  -- 原因可能与设置了不能从可写的区域执行代码有关 (update: AP=0b00,0b10,0b11均可)

# 2018年3月2日20:32:17
其他有用的参考：https://github.com/PeterLemon/RaspberryPi，https://github.com/LdB-ECM/Raspberry-Pi
包含一些USB和图形等方面的参考

https://github.com/forkachild/NarcOS

# 2018年2月28日19:57:23
编写位置无关的代码及其测试：
1.使用QEMU
	生成系统镜像
	计算其大小size，保证为4的倍数（PC对齐检查）
	复制一份，附加到原镜像的末尾
	在代码的测试部分，增加PC的值为4+size，如果正常跳转到下一条指令到最后，说明PIC成功
缺点：所有的地址访问都是基于PC的，因此RAM也需要复制，麻烦

-pie, --pic-executable      Create a position independent executable
-fpic                       Generate position-independent code if possible

选择使用-fpic


# 2018年2月28日15:24:07
对虚拟内存进行测试，过程如下：
选择EL1 & EL0的非安全模式，只有一个阶段的转换，这将减少实现的复杂度。
系统初始化完成后，首先确定系统支持的转换地址的位数，一般是48位，在QEMU上是40位，然而这个值可以变化，程序有能力保证不同的数值有正确的设置。读取ID\_AA64MMFR0_EL1.PARange的值即可。少于标准48位的，认为其高部分恒为0即可，因此在这些情况下，输入地址仍然是48位的。
确定每级页表的基地址和内容，n级页表的内容由n+1级页表的基地址及其内存属性构成。
确定转换表的粒度：4KB，但是需要确定该粒度是否支持，通过ID\_AA64MMFR0_EL1.TGRAN{4,16,64}==0b0000来确定。
确定映射方案：内核和程序都必须使用RAM，由于EL2/EL3只能使用第一个地址空间，因此为了兼容性考虑，只能将RAM映射到第一个地址空间，此外，当考虑到分配内存时，如果返回一个内核空间的地址，则程序将会无权访问。RAM如果已经存在于程序空间，并且空出的大小合适，则不需要对RAM进行额外的映射。
在启用MMU之后，地址关系已经改变，此时必须重新使用新的全局变量的地址，这些地址不能使用PIC，只能使用绝对地址。因此，内核分为两个部分单独编译，第一部分：PIC  第二部分：启用MMU之后，非PIC选项 -- 弃用
启用MMU之后的一段代码所处的地址必须是直接映射的，一般这段代码的地址空间位于程序空间。设其物理地址是P，虚拟地址是V，
启用MMU之后的一段代码必须进行ISB，然后跳转到高地址空间进行，如果目标跳转函数是A，只需要获取A与原始基地址的偏移，加上高端基地址即可。

决定转换表中内存区域的属性，对于QEMU，前面的内存一部分是Device。 属性主要影响缓存，访问权限，可读可写性

设置转换表：
	flatten映射表： 

设置TCR_EL1.IPS, 它必须小于等于PARange的位数
设置T0SZ,T1SZ, 它们决定输入地址的位数，通过决定具有特殊含义的高位的数目。通常设置为与PARange产生的结果一致即可。VA的所有有特殊意义的位的值必须全部相同。TxSZ其实决定了转换表遍历的起始级别，保存该起始级别的转换表基地址所需的额外位数，这也减少了转换表的大小。

TTBR的基地址受OA的影响，其高出OA的位必须为RES0

4KB转换中，PA[11:0]=VA[11:0]

必须保证启用MMU之后的ISB指令也能被执行，但是启用MMU的指令地址是已知的，因此必须编写位置无关(PIC)的代码。

禁用地址标签，该转换阶段支持两个地址空间，需要分别设置。就一般而言，全1为kernel，全0为user


在非安全状态，NSTable和NS位会被忽略

TLB缓存，如果一个虚拟地址已经被缓存，则其物理地址立即可得。如果修改了某个位置的页表，则程序本身必须负责使用TLB管理指令。
此外，对于转换表中的nG=1的项，当其被加入到TLB中时，会关联一个ASID值，因此不必在上下文切换时使所有的表项失效。


AF=0，则第一次访问时会产生fault

转换过程：
 输入地址VA[47:0]
 级别0：TTBR_EL1[47:12] & VA[47:39] & 0b000 --> 指向VB1
 级别1：VB1[4
 
最后，通过SCTLR_ELx.M=1来启用这个转换阶段

当前情况下，我们只考虑所有的内存都由EL1访问，即高权限的。


如果是在树莓派上，确保关闭了安全扩展（EL3）和虚拟化扩展（EL2），剩下的就是非安全的EL1和EL0.


附：上下文切换需要保存的状态
- 通用寄存器X0~X30
- V0-V31
- 一些状态寄存器
- TTBR0_EL1和TTBR0
- 线程进程标识ID寄存器(TPIDxxx)
- 地址空间ID(ASID)